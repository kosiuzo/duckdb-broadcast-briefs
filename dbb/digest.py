"""Email digest rendering and sending."""

import logging
import smtplib
import re
from datetime import datetime, timedelta
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from pathlib import Path
from typing import List, Dict, Any, Tuple
from collections import defaultdict

from jinja2 import Environment, FileSystemLoader, Template
from premailer import Premailer

from dbb.config import Config
from dbb.utils import write_file, truncate_string

logger = logging.getLogger(__name__)


def markdown_to_html(text: str) -> str:
    """
    Convert basic markdown to HTML (simple implementation).

    Args:
        text: Markdown text

    Returns:
        HTML text
    """
    if not text:
        return ""

    # Convert markdown headers to HTML headers
    text = re.sub(r'^### (.*?)$', r'<h4>\1</h4>', text, flags=re.MULTILINE)
    text = re.sub(r'^## (.*?)$', r'<h3>\1</h3>', text, flags=re.MULTILINE)
    text = re.sub(r'^# (.*?)$', r'<h2>\1</h2>', text, flags=re.MULTILINE)

    # Convert bold markdown to HTML
    text = re.sub(r'\*\*(.*?)\*\*', r'<strong>\1</strong>', text)
    text = re.sub(r'__(.*?)__', r'<strong>\1</strong>', text)

    # Convert italic markdown to HTML
    text = re.sub(r'\*(.*?)\*', r'<em>\1</em>', text)
    text = re.sub(r'_(.*?)_', r'<em>\1</em>', text)

    # Convert bullet lists to HTML
    text = re.sub(r'^\s*- (.*?)$', r'<li>\1</li>', text, flags=re.MULTILINE)
    text = re.sub(r'(<li>.*?</li>)', r'<ul>\1</ul>', text, flags=re.DOTALL)

    # Convert line breaks to HTML
    text = text.replace('\n\n', '</p><p>')
    text = f'<p>{text}</p>'

    return text


class DigestRenderer:
    """Renders email digests from episode data."""

    def __init__(self, config: Config):
        """
        Initialize digest renderer.

        Args:
            config: Application configuration
        """
        self.config = config
        self.template_dir = Path("templates")

    def _load_template(self, template_name: str) -> Template:
        """Load Jinja2 template."""
        try:
            template_path = self.template_dir / template_name
            with open(template_path, "r") as f:
                return Template(f.read())
        except FileNotFoundError:
            logger.warning(f"Template not found: {template_path}, using default")
            if template_name == "digest.html":
                return Template(self._default_html_template())
            else:
                return Template(self._default_text_template())

    @staticmethod
    def _default_html_template() -> str:
        """Default HTML email template."""
        return """<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; }
        h1 { color: #333; border-bottom: 2px solid #007bff; padding-bottom: 10px; }
        h2 { color: #555; margin-top: 30px; }
        .episode { background: #f9f9f9; padding: 15px; margin-bottom: 15px; border-radius: 5px; }
        .episode h3 { margin-top: 0; color: #007bff; }
        .summary { color: #666; line-height: 1.6; }
        .links { margin-top: 10px; }
        .links a { display: inline-block; margin-right: 15px; color: #007bff; text-decoration: none; }
        .toc { background: #f0f0f0; padding: 15px; margin-bottom: 20px; border-radius: 5px; }
        .toc a { display: block; color: #007bff; text-decoration: none; margin: 5px 0; }
        .channel-section { page-break-inside: avoid; }
        footer { margin-top: 40px; border-top: 1px solid #ddd; padding-top: 20px; font-size: 12px; color: #999; }
    </style>
</head>
<body>
    <h1>{{ title }}</h1>

    {% if toc %}
    <div class="toc">
        <h3>Table of Contents</h3>
        {% for channel in toc %}
        <a href="#channel-{{ loop.index0 }}">{{ channel }}</a>
        {% endfor %}
    </div>
    {% endif %}

    {% for channel, episodes in episodes_by_channel.items() %}
    <div class="channel-section" id="channel-{{ loop.index0 }}">
        <h2>{{ channel }}</h2>
        {% for episode in episodes %}
        <div class="episode">
            <h3>{{ episode.title }}</h3>
            <div class="summary">{{ episode.summary_html|safe }}</div>
            <div class="links">
                <a href="{{ episode.url }}">Watch on YouTube</a>
                {% if episode.transcript_path %}
                <a href="{{ episode.transcript_path }}">Transcript</a>
                {% endif %}
            </div>
        </div>
        {% endfor %}
    </div>
    {% endfor %}

    <footer>
        <p>This digest was automatically generated by DuckDB Broadcast Briefs</p>
    </footer>
</body>
</html>"""

    @staticmethod
    def _default_text_template() -> str:
        """Default plaintext email template."""
        return """{{ title }}
${'=' * title|length}

{% for channel, episodes in episodes_by_channel.items() %}

{{ channel }}
{{ '-' * channel|length }}

{% for episode in episodes %}
Title: {{ episode.title }}
URL: {{ episode.url }}
{% if episode.transcript_path %}Transcript: {{ episode.transcript_path }}{% endif %}

Summary:
{{ episode.summary_md }}

---

{% endfor %}
{% endfor %}

---
This digest was automatically generated by DuckDB Broadcast Briefs
"""

    def render_digest(self, episodes: List[Dict[str, Any]], date_range: Tuple[datetime, datetime]) -> Tuple[str, str]:
        """
        Render digest HTML and plaintext.

        Args:
            episodes: List of episode dictionaries
            date_range: Tuple of (start_date, end_date)

        Returns:
            Tuple of (html_content, text_content)
        """
        start_date, end_date = date_range

        # Group episodes by channel and convert markdown to HTML
        episodes_by_channel = defaultdict(list)
        for episode in episodes:
            channel = episode.get("channel_title", "Unknown")
            # Convert markdown summary to HTML for HTML emails
            if episode.get("summary_md"):
                episode["summary_html"] = markdown_to_html(episode["summary_md"])
            else:
                episode["summary_html"] = ""
            episodes_by_channel[channel].append(episode)

        # Sort each channel's episodes
        for channel in episodes_by_channel:
            episodes_by_channel[channel].sort(
                key=lambda e: e.get("published_at", datetime.now()),
                reverse=True
            )

        # Template context
        context = {
            "title": f"Your Weekly Podcast Digest ({start_date.strftime('%Y-%m-%d')} â€“ {end_date.strftime('%Y-%m-%d')})",
            "episodes_by_channel": dict(episodes_by_channel),
            "toc": list(episodes_by_channel.keys()),
            "start_date": start_date.strftime("%Y-%m-%d"),
            "end_date": end_date.strftime("%Y-%m-%d"),
        }

        # Render HTML
        html_template = self._load_template("digest.html")
        html_content = html_template.render(**context)

        # Inline CSS for email compatibility
        try:
            premailer = Premailer(html_content)
            html_content = premailer.transform()
            logger.debug("CSS inlined with Premailer")
        except Exception as e:
            logger.warning(f"CSS inlining failed: {e}")

        # Render plaintext
        text_template = self._load_template("digest.txt")
        text_content = text_template.render(**context)

        logger.info("Digest rendered successfully")
        return html_content, text_content


class DigestSender:
    """Sends email digests via SMTP."""

    def __init__(self, config: Config):
        """
        Initialize digest sender.

        Args:
            config: Application configuration
        """
        self.config = config

    def send_digest(self, html_content: str, text_content: str, subject: str) -> bool:
        """
        Send digest email.

        Args:
            html_content: HTML version of digest
            text_content: Plaintext version of digest
            subject: Email subject line

        Returns:
            True if sent successfully, False otherwise
        """
        if not self.config.email.enabled:
            logger.info("Email sending disabled in config")
            return False

        try:
            # Create message
            msg = MIMEMultipart("alternative")
            msg["Subject"] = subject
            msg["From"] = f"{self.config.email.from_name} <{self.config.email.from_email}>"
            msg["To"] = ", ".join(self.config.email.recipients)

            # Attach plaintext and HTML versions
            msg.attach(MIMEText(text_content, "plain"))
            msg.attach(MIMEText(html_content, "html"))

            # Send via SMTP
            smtp_config = self.config.smtp
            with smtplib.SMTP(smtp_config.host, smtp_config.port) as server:
                if smtp_config.use_tls:
                    server.starttls()

                server.login(smtp_config.username, smtp_config.password)
                server.send_message(msg)

            logger.info(f"Digest sent to {len(self.config.email.recipients)} recipient(s)")
            return True

        except smtplib.SMTPAuthenticationError as e:
            logger.error(f"SMTP authentication failed: {e}")
            return False
        except smtplib.SMTPException as e:
            logger.error(f"SMTP error: {e}")
            return False
        except Exception as e:
            logger.error(f"Email sending failed: {e}")
            return False


def save_digest_previews(html_content: str, text_content: str) -> None:
    """
    Save digest previews to files.

    Args:
        html_content: HTML digest content
        text_content: Plaintext digest content
    """
    html_path = Path("digest_preview.html")
    text_path = Path("digest_preview.txt")

    write_file(html_path, html_content)
    write_file(text_path, text_content)

    logger.info(f"Digest previews saved to {html_path} and {text_path}")
